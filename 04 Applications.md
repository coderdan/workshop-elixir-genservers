# GenServer in Applications

Preloading scores - use `init`

Set the state:

```elixir
defmodule Scores do
  use GenServer

  def init(scores) do
    {:ok, scores}
  end
end
```

Now when we call `start_link` we can pass the initial state:

`{:ok, pid} = GenServer.start_link(Scores, %{dan: 100})`

Supervisor

We might want to have our genserver start automatically when our application starts.

First we should give our server the right interface.

Take a look at the `lib/scores/application.ex` file:

```elixir
defmodule Scores.Application do
  @moduledoc false

  use Application

  def start(_type, _args) do
    # List all child processes to be supervised
    children = [

    ]

    opts = [strategy: :one_for_one, name: Scores.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
```

When the application is started a list of child processes can be started as well.

We can add our scores server by adding an item to the list of children:

But for this to work, our server must implement a “Child Spec” which looks like this:

```elixir
def child_spec(opts) do
  %{
    id: Scores,
    start: {Scores, :start_link, [opts]}
  }
end
```

This tells the supervisor to call the `start_link` function on the `Scores` module with a single argument (in this case the empty map).

So we might first observe that there isn’t actually a `start_link` function in our Scores module. So lets create one:

```elixir
  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts)
  end
```

And actually, when we `use GenServer` we get a `child_spec/1` function for free which looks just like the one above. So by adding the `start_link` function our scores server should now satisfy the spec. Let’s add a little message so we know that’s the case:

```elixir
  def start_link(opts) do
    IO.puts("Starting Scores server")
    GenServer.start_link(__MODULE__, opts)
  end
```

Finally, we add our `Scores` server to the children list in our application.

```elixir
children = [
  Scores
]
```

We could also do:

```elixir
children = [
  {Scores, scores: %{dan: 100}}
]
```

Which is actually equivalent to:

```elixir
children = [
  Scores.child_spec(scores: %{dan: 100})
]
```

And of course we could even override the `child_spec/1` function generated by GenServer if we wanted.

Lets start our application:

```
iex -S mix
Compiling 1 file (.ex)
Starting Scores server
```

The Scores server started!

But there is a problem…what is the PID now that it is started for us??

We can register a name for the `GenServer`:

```elixir
{:ok, _} = GenServer.start_link(Scores, [], name: Scores)
```

The name can be anything you like but we’ll just use the module itself (an atom). Note that a pid will be returned from the call above but we don’t care what it is.

So we can update our `start_link` function:

```elixir
def start_link(arg) do
  IO.puts("Starting Scores server")
  GenServer.start_link(__MODULE__, arg, name: __MODULE__)
end
```

Now we can do:

```elixir
GenServer.call(Scores, {:get_score, :dan})
```

And that means we can do:

```elixir
Scores.get_score(Scores, :dan)
```

If we only plan to run one scores server in our application then the first argument is redundant and we can do:

```elixir
  def set_score(name, score) do
    GenServer.call(__MODULE__, {:set_score, name, score})
  end
```

And so on for all of our functions.